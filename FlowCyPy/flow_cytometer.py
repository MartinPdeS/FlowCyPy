#!/usr/bin/env python
# -*- coding: utf-8 -*-
from typing import Optional
import pandas as pd
import numpy as np
from TypedUnit import Power, Time, ureg, validate_units

from FlowCyPy.fluidics import Fluidics
from FlowCyPy.opto_electronics import OptoElectronics
from FlowCyPy.signal_generator import SignalGenerator
from FlowCyPy.signal_processing import SignalProcessing
from FlowCyPy.simulation_settings import SimulationSettings
from FlowCyPy.sub_frames.acquisition import AcquisitionDataFrame
from FlowCyPy.run_record import RunRecord


from FlowCyPy.event_collection import EventCollection
import pint_pandas
from FlowCyPy.sampling_method import GammaModel, ExplicitModel


class FlowCytometer:
    """
    A simulation class for modeling flow cytometer signals, including Forward Scatter (FSC) and Side Scatter (SSC) channels.

    The FlowCytometer class integrates optical and flow dynamics to simulate signal generation in a flow cytometer.
    It handles particle distributions, flow cell properties, laser source configurations, and detector behavior to
    replicate realistic cytometry conditions. This includes the generation of synthetic signal pulses for each
    particle event and noise modeling for accurate signal representation.

    Parameters
    ----------
    opto_electronics : OptoElectronics
        An instance of the OptoElectronics class, which contains the configuration of detectors, digitizer, source, and amplifier.
    fluidics : Fluidics
        An instance of the Fluidics class, which manages the flow cell and scatterer collection.
    background_power : pint.Quantity, optional
        The background power level in the system, defaulting to 0 mW. This represents the constant background signal that is present in the system, which can affect the detection of actual signals.

    Raises
    ------
    AssertionError
        If the number of detectors provided is not exactly two, or if both detectors share the same name.

    """

    @validate_units
    def __init__(
        self,
        opto_electronics: OptoElectronics,
        fluidics: Fluidics,
        signal_processing: SignalProcessing,
        background_power: Optional[Power] = 0 * ureg.milliwatt,
    ):
        self.fluidics = fluidics
        self.background_power = background_power
        self.opto_electronics = opto_electronics
        self.signal_processing = signal_processing

    def _create_signal_generator(self, run_time: Time) -> SignalGenerator:
        """
        Creates a signal generator for the flow cytometer.

        This method initializes a signal generator with the specified run time and prepares it
        to generate signals based on the flow cytometer's configuration.

        Parameters
        ----------
        run_time : pint.Quantity
            The duration of the acquisition in seconds.

        Returns
        -------
        SignalGenerator
            An instance of `SignalGenerator` configured for the flow cytometer.
        """
        time_series = self.signal_processing.digitizer.get_time_series(
            run_time=run_time
        )

        signal_generator = SignalGenerator(
            n_elements=len(time_series), time_units=ureg.second, signal_units=ureg.watt
        )

        signal_generator.add_time(time_series)

        for detector in self.opto_electronics.detectors:
            signal_generator.create_zero_signal(signal_name=detector.name)

        return signal_generator

    def _distribute_events(self, population_events) -> None:
        """
        Distributes events across detectors.

        This method is a placeholder for distributing events to the appropriate detectors.
        """
        for detector in self.opto_electronics.detectors:
            detector.events = []
            for events in population_events:
                if detector.channel_type.lower() == "scattering":
                    detector.events.append(events)

                if detector.channel_type.lower() == events.channel_type.lower():
                    detector.events.append(events)

    def compute_analog(
        self, run_time: Time, event_collection: pd.DataFrame
    ) -> AcquisitionDataFrame:
        """
        Simulates the complete analog optical response generated by all detected particle events.

        This function builds the full analog waveform that emerges from the optical and
        opto electronic chain of the cytometer. It proceeds in three major stages:

        1. Optical domain
        - Creates an optical power time series for each detector
        - For explicit sampling models, generates Gaussian shaped pulses directly
        - For gamma models, draws a gamma distributed power trace that matches the
            expected total particle contribution and optionally smooths it with a
            Gaussian convolution
        - Adds the constant background optical power

        2. Conversion to photocurrent
        - Converts optical power to photocurrent using the detector responsivity
            and the illumination wavelength
        - Applies bandwidth dependent effects from the digitizer

        3. Current domain to voltage domain
        - Adds optional dark current noise when enabled in simulation settings
        - Passes all photocurrents through the analog amplifier model
        - Applies final analog conditioning and filtering steps

        The output is returned as an AcquisitionDataFrame, which contains voltage
        waveforms for all detectors on a shared time base, formatted with a clear
        multi level index.

        Parameters
        ----------
        run_time : Time
            Total simulated duration of the acquisition
        event_collection : pandas.DataFrame
            Collection of detected particle events, where each entry contains the
            event time, width, amplitude, velocity, and sampling method

        Returns
        -------
        AcquisitionDataFrame
            Structured representation of the final analog voltage signals for all
            detectors, including the time axis and processed analog waveforms

        Raises
        ------
        ValueError
            If required event fields are missing, including Sigmas or Time for
            explicit pulse generation
        """
        signal_generator = self._create_signal_generator(run_time=run_time)
        signal_generator.signal_units = ureg.watt  # Initial unit: optical power
        signal_generator.add_constant(constant=self.background_power)

        for detector in self.opto_electronics.detectors:
            for events in event_collection:
                if events.sampling_method == "ExplicitModel":
                    if not events.empty:
                        signal_generator.generate_pulses(
                            signal_name=detector.name,
                            sigmas=events["Sigmas"]
                            .pint.to_base_units()
                            .values.quantity,
                            centers=events["Time"].pint.to_base_units().values.quantity,
                            amplitudes=events[detector.name]
                            .pint.to_base_units()
                            .values.quantity,
                            base_level=0 * ureg.watt,
                        )
                elif events.sampling_method == "GammaModel":

                    velocity = events["Velocity"].pint.quantity.mean()

                    interrogation_volume_per_time_bin = (
                        velocity
                        / self.signal_processing.digitizer.sampling_rate
                        * self.fluidics.flow_cell.sample.area
                    ).mean()

                    expected_number_of_particles = (
                        (
                            events.population.particle_count
                            * interrogation_volume_per_time_bin
                        )
                        .to("particle")
                        .magnitude
                    )

                    amplitudes = (
                        events[detector.name].pint.to("watt").values.quantity.magnitude
                    )
                    mean_amplitudes = np.mean(amplitudes)
                    mean_squared_amplitudes = np.mean(amplitudes**2)

                    mean_sum = expected_number_of_particles * mean_amplitudes
                    var_sum = expected_number_of_particles * mean_squared_amplitudes

                    shape = mean_sum**2 / var_sum
                    scale = var_sum / mean_sum

                    signal_generator._cpp_add_gamma_trace(
                        signal_name=detector.name,
                        shape=shape,
                        scale=scale,
                        gaussian_sigma=events.sigmas.mean().to("second").magnitude,
                    )

        # Optical power → photocurrent
        for detector in self.opto_electronics.detectors:
            detector._transform_coupling_power_to_current(
                signal_generator=signal_generator,
                wavelength=self.opto_electronics.source.wavelength,
                bandwidth=self.signal_processing.digitizer.bandwidth,
            )

        # Add dark current noise if enabled
        signal_generator.signal_units = ureg.ampere
        if (
            SimulationSettings.include_noises
            and SimulationSettings.include_dark_current_noise
        ):
            for detector in self.opto_electronics.detectors:
                detector.apply_dark_current_noise(
                    signal_generator=signal_generator,
                    bandwidth=self.signal_processing.digitizer.bandwidth,
                )

        # Photocurrent → voltage
        signal_generator.signal_units = ureg.volt
        self.opto_electronics.amplifier.amplify(
            signal_generator=signal_generator,
            sampling_rate=self.signal_processing.digitizer.sampling_rate,
        )

        # Final analog signal conditioning
        self.signal_processing.process_analog(signal_generator)

        # Create structured DataFrame output
        analog_aquisition = AcquisitionDataFrame._construct_from_signal_generator(
            signal_generator=signal_generator,
            time_units="second",
            signal_units="volt",
        )

        return analog_aquisition

    def run(self, run_time: Time) -> RunRecord:
        """
        Runs a complete flow cytometry simulation for the specified acquisition duration.

        The pipeline includes:
        1. Initialization and setup of fluidic/optical components
        2. Particle event simulation and optical signal generation
        3. Analog and digital signal processing
        4. Triggered signal extraction and peak feature detection

        Parameters
        ----------
        run_time : Time
            Duration of the simulated acquisition (e.g., `1.0 * ureg.millisecond`).
        compute_cross_section : bool, optional
            Whether to compute the scattering cross-section for each event. Default is False.

        Returns
        -------
        RunRecord
            Simulation output containing all analog, digital, and peak-level data.
        """
        event_collection = self.generate_event_collection(run_time=run_time)

        analog = self.compute_analog(
            event_collection=event_collection, run_time=run_time
        )

        run_record = RunRecord(
            run_time=run_time,
            detector_names=[d.name for d in self.opto_electronics.detectors],
            event_collection=event_collection,
            analog=analog,
        )

        if self.signal_processing.triggering_system is not None:
            run_record.signal.analog_triggered = (
                self.signal_processing.triggering_system.run(dataframe=analog)
            )

            run_record.signal.digital = run_record.signal.analog_triggered.digitalize(
                digitizer=self.signal_processing.digitizer
            ).normalize_units(signal_units=ureg.bit_bins)

            if self.signal_processing.peak_algorithm is not None:
                run_record.peaks = self.signal_processing.peak_algorithm.run(
                    run_record.signal.digital
                )

            run_record.triggering_system = self.signal_processing.triggering_system

        return run_record

    @validate_units
    def generate_event_collection(self, run_time: Time) -> EventCollection:
        """
        Generates a DataFrame of event times and sampled velocities for each population based on the specified scheme.
        """
        event_collection = EventCollection()

        for population in self.fluidics.scatterer_collection.populations:

            if isinstance(population.sampling_method, ExplicitModel):
                arrival_times = self.fluidics.get_arrival_times(
                    population=population, run_time=run_time
                )

                n_events = len(arrival_times)

                dataframe = pd.DataFrame(index=range(n_events))

                dataframe["Time"] = pint_pandas.PintArray(
                    arrival_times.magnitude, arrival_times.units
                )

                self.fluidics.flow_cell.add_transverse_profile_to_frame(dataframe)

                population.add_property_to_frame(dataframe=dataframe)

                dataframe["Sigmas"] = self.opto_electronics.source.get_particle_width(
                    velocity=dataframe["Velocity"]
                )

            elif isinstance(population.sampling_method, GammaModel):
                n_events = population.sampling_method.mc_samples

                dataframe = pd.DataFrame(index=range(n_events))

                self.fluidics.flow_cell.add_transverse_profile_to_frame(dataframe)

                population.add_property_to_frame(dataframe=dataframe)

                dataframe.velocity = dataframe["Velocity"].mean()

                dataframe.sigmas = self.opto_electronics.source.get_particle_width(
                    velocity=dataframe["Velocity"]
                ).mean()

                dataframe.interrogation_volume_per_time_bin = (
                    dataframe.velocity
                    / self.signal_processing.digitizer.sampling_rate
                    * self.fluidics.flow_cell.sample.area
                ).mean()

                dataframe.expected = (
                    (
                        population.particle_count
                        * dataframe.interrogation_volume_per_time_bin
                    )
                    .to("particle")
                    .magnitude
                )

            dataframe.sampling_method = population.sampling_method.__class__.__name__

            dataframe.population = population

            dataframe.scatterer_type = population.__class__.__name__

            event_collection.events_list.append(dataframe)

        self.opto_electronics._add_coupling_to_dataframe(
            event_collection=event_collection,
            compute_cross_section=False,
        )

        return event_collection

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks, peak_widths
from MPSPlots.styles import mps
from FlowCytometry import Peak

class PulseAnalyzer:
    """
    A class to analyze pulse signals generated by a flow cytometer, extracting features
    such as pulse height, width, and area.

    Attributes
    ----------
    time : numpy.ndarray
        The time axis corresponding to the signal.
    signal : numpy.ndarray
        The raw signal to be analyzed (e.g., FSC or SSC signal).
    height_threshold : float
        The minimum height required for a peak to be considered significant.
    peaks : list of Peak
        A list of Peak objects representing the detected peaks.

    Methods
    -------
    find_peaks():
        Detects peaks in the raw signal based on the height threshold.
    calculate_widths():
        Calculates the widths of the detected peaks at half maximum.
    calculate_areas():
        Calculates the areas under the detected peaks.
    display_features():
        Displays the extracted features such as heights, widths, and areas.
    plot():
        Plots the signal along with detected peaks, widths, and areas on a time axis.
    """

    def __init__(self, time, signal, height_threshold):
        """
        Constructs all the necessary attributes for the PulseAnalyzer object.

        Parameters
        ----------
        time : numpy.ndarray
            The time axis corresponding to the signal.
        signal : numpy.ndarray
            The raw signal to be analyzed (e.g., FSC or SSC signal).
        height_threshold : float
            The minimum height required for a peak to be considered significant.
        """
        self.time = time
        self.signal = signal
        self.height_threshold = height_threshold
        self.peaks = []

    def find_peaks(self):
        """
        Detects peaks in the raw signal based on the height threshold.
        """
        peak_indices, _ = find_peaks(self.signal, height=self.height_threshold)
        peak_heights = self.signal[peak_indices]

        for idx, height in zip(peak_indices, peak_heights):
            self.peaks.append(Peak(time=self.time[idx], height=height, width=None))

    def calculate_widths(self):
        """
        Calculates the widths of the detected peaks at half maximum.
        """
        if self.peaks:
            peak_indices = [np.where(self.time == peak.time)[0][0] for peak in self.peaks]
            widths = peak_widths(self.signal, peak_indices, rel_height=0.5)[0]

            dt = self.time[1] - self.time[0]
            for peak, width in zip(self.peaks, widths):
                peak.width = width * dt

    def calculate_areas(self):
        """
        Calculates the areas under the detected peaks.

        The area is calculated by integrating the signal around each detected peak.
        """
        for peak in self.peaks:
            if peak.width is not None:
                peak.calculate_area(self.signal, self.time)

    def display_features(self):
        """
        Displays the extracted features such as heights, widths, and areas.
        """
        for i, peak in enumerate(self.peaks[:5]):  # Display up to 5 peaks for brevity
            print(f"Peak {i + 1}:")
            print(f"  Time: {peak.time}")
            print(f"  Height: {peak.height}")
            print(f"  Width: {peak.width}")
            print(f"  Area: {peak.area}")

    def plot(self) -> None:
        """
        Plots the signal along with detected peaks, widths, and areas.
        """
        with plt.style.context(mps):
            plt.figure(figsize=(10, 6))
            plt.plot(self.time, self.signal, label='Signal')

            for peak in self.peaks:
                plt.plot(peak.time, peak.height, 'x', label='Peaks')
                plt.hlines(y=peak.height / 2, xmin=peak.time - peak.width / 2, xmax=peak.time + peak.width / 2, colors='r', label='Width at Half-Max')

            plt.legend()
            handles, labels = plt.gca().get_legend_handles_labels()
            by_label = dict(zip(labels, handles))
            plt.legend(by_label.values(), by_label.keys())

            plt.title('Pulse Analysis')
            plt.xlabel('Time')
            plt.ylabel('Signal Amplitude')

            plt.grid(True)
            plt.show()

